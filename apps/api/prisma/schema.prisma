generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  user_id                                          Int                 @id @default(autoincrement())
  nickname                                         String              @db.VarChar(50)
  email                                            String              @unique @db.VarChar(100)
  password_hash                                    String
  cluster_id                                       Int?
  created_date                                     DateTime            @default(now()) @db.Timestamp(6)
  diary_reminder                                   DateTime?           @db.Time(6)
  bgm_volume                                       Float               @default(0.5)
  sfx_volume                                       Float               @default(0.5)
  user_type                                        Int?
  used_flag                                        Int                 @default(1)
  kakao_id                                         String?             @db.VarChar(50)
  bgms                                             BGM[]
  diaries                                          Diary[]
  EmotionPrediction                                EmotionPrediction[]
  notifications                                    Notification[]
  objects                                          Object[]
  reports                                          Report[]
  SharedObject_SharedObject_giver_user_idToUser    SharedObject[]      @relation("SharedObject_giver_user_idToUser")
  SharedObject_SharedObject_receiver_user_idToUser SharedObject[]      @relation("SharedObject_receiver_user_idToUser")
  cluster                                          ClusterGroup?       @relation(fields: [cluster_id], references: [cluster_id], onDelete: Restrict)
}

model Diary {
  diary_id      Int            @id @default(autoincrement())
  user_id       Int
  original_text String
  emotion_id    Int?           @unique
  object_id     Int?           @unique
  created_date  DateTime       @default(now()) @db.Timestamp(6)
  input_type    Int
  flag          Int
  bgms          BGM[]
  emotionResult EmotionResult? @relation(fields: [emotion_id], references: [emotion_id], onDelete: Restrict)
  user          User           @relation(fields: [user_id], references: [user_id])
  object        Object?
}

model ClusterGroup {
  cluster_id              Int                    @id @default(autoincrement())
  centroid_vector         Unsupported("vector")?
  representative_emotions Int
  representative_keywords String[]
  user_count              Int                    @default(0)
  updated_at              DateTime               @default(now()) @db.Timestamp(6)
  description             String
  SharedObject            SharedObject[]
  users                   User[]
}

model EmotionResult {
  emotion_id      Int                    @id @default(autoincrement())
  diary_id        Int                    @unique
  summary_text    String?
  main_emotion    Int?
  keyword_1       String?                @db.VarChar(30)
  keyword_2       String?                @db.VarChar(30)
  keyword_3       String?                @db.VarChar(30)
  embedding       Unsupported("vector")?
  emotion_softmax Unsupported("vector")?
  day_vector      Unsupported("vector")?
  BGM             BGM[]
  diary           Diary?
  Object          Object[]
  SharedObject    SharedObject[]
}

model Object {
  object_id            Int                    @id @default(autoincrement())
  emotion_id           Int?
  user_id              Int
  diary_id             Int?                   @unique
  object_name          String                 @db.VarChar(50)
  object_image         String
  created_date         DateTime               @default(now()) @db.Timestamp(6)
  ClusterDefaultObject ClusterDefaultObject[]
  Diary                Diary?                 @relation(fields: [diary_id], references: [diary_id], onDelete: Cascade)
  EmotionResult        EmotionResult?         @relation(fields: [emotion_id], references: [emotion_id], onDelete: Restrict)
  user                 User                   @relation(fields: [user_id], references: [user_id])
  SharedObject         SharedObject[]
}

model BGM {
  bgm_id        Int           @id @default(autoincrement())
  user_id       Int
  emotion_id    Int
  diary_id      Int
  bgm_url       String?
  created_date  DateTime      @default(now()) @db.Timestamp(6)
  diary         Diary         @relation(fields: [diary_id], references: [diary_id])
  EmotionResult EmotionResult @relation(fields: [emotion_id], references: [emotion_id])
  user          User          @relation(fields: [user_id], references: [user_id])
}

model Report {
  report_id            Int      @id @default(autoincrement())
  user_id              Int
  start_date           DateTime @db.Date
  end_date             DateTime @db.Date
  summary_text         String?
  encouragement_text   String?
  emotion_distribution Json?
  created_date         DateTime @default(now()) @db.Timestamp(6)
  user                 User     @relation(fields: [user_id], references: [user_id])
}

model Notification {
  notify_id    Int      @id @default(autoincrement())
  user_id      Int
  type         Int      @default(0)
  title        String   @db.VarChar(100)
  message      String?
  is_read      Boolean  @default(false)
  created_date DateTime @default(now()) @db.Timestamp(6)
  user         User     @relation(fields: [user_id], references: [user_id], onDelete: Cascade, onUpdate: NoAction, map: "fk_notification_user")
}

model EmotionPrediction {
  prediction_id     Int                    @id @default(autoincrement())
  user_id           Int
  predicted_emotion Int?
  emotion_softmax   Unsupported("vector")?
  main_emotion      Int?
  created_date      DateTime               @default(now()) @db.Timestamp(6)
  User              User                   @relation(fields: [user_id], references: [user_id], onDelete: Cascade, onUpdate: NoAction, map: "fk_user_id")
}

model SharedObject {
  share_id                                 Int            @id @default(autoincrement())
  giver_user_id                            Int
  receiver_user_id                         Int
  object_id                                Int
  emotion_id                               Int?
  share_type                               Int            @default(0)
  cluster_id                               Int?
  note                                     String?
  created_date                             DateTime       @default(now()) @db.Timestamp(6)
  ClusterGroup                             ClusterGroup?  @relation(fields: [cluster_id], references: [cluster_id], onUpdate: NoAction, map: "fk_cluster")
  EmotionResult                            EmotionResult? @relation(fields: [emotion_id], references: [emotion_id], onUpdate: NoAction, map: "fk_emotion")
  User_SharedObject_giver_user_idToUser    User           @relation("SharedObject_giver_user_idToUser", fields: [giver_user_id], references: [user_id], onDelete: Cascade, onUpdate: NoAction, map: "fk_giver_user")
  Object                                   Object         @relation(fields: [object_id], references: [object_id], onDelete: Cascade, onUpdate: NoAction, map: "fk_object")
  User_SharedObject_receiver_user_idToUser User           @relation("SharedObject_receiver_user_idToUser", fields: [receiver_user_id], references: [user_id], onDelete: Cascade, onUpdate: NoAction, map: "fk_receiver_user")
}

model ClusterDefaultObject {
  cluster_id Int       @id
  object_id  Int
  created_at DateTime? @default(now()) @db.Timestamptz(6)
  updated_at DateTime? @default(now()) @db.Timestamptz(6)
  Object     Object    @relation(fields: [object_id], references: [object_id], map: "fk_clusterdefaultobject_object")
}
